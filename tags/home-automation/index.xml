<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>home-automation on karl</title><link>https://karlquinsland.com/tags/home-automation/</link><description>Recent content in home-automation on karl</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 20 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://karlquinsland.com/tags/home-automation/index.xml" rel="self" type="application/rss+xml"/><item><title>Two Tasmota rules</title><link>https://karlquinsland.com/2020/11/two-tasmota-rules/</link><pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate><guid>https://karlquinsland.com/2020/11/two-tasmota-rules/</guid><description>&lt;p>&lt;a href="https://tasmota.github.io/">Tasmota&lt;/a> is an incredibly powerful alternative/open source firmware for the ever popular Espressif family of WiFi equipped microcontrollers.
This does not need to be another post espousing it&amp;rsquo;s many awesome qualities, so just trust me on this; Tasmota is AWESOME.&lt;/p>
&lt;p>Tasmota supports user configurable &lt;a href="https://tasmota.github.io/docs/Rules/">rules&lt;/a> which are simple commands wired into various device triggers.
In short; a device running Tasmota gains some autonomy to react to events without needing to report the event to, and wait for commands from, a remote server.&lt;/p>
&lt;p>I find the rules syntax to be a bit awkward and the list of practical examples feels like autodoc with a few practical examples sprinkled in.
I have &lt;em>never&lt;/em> been able to craft a Tasmota rule without also consulting the list of &lt;a href="https://tasmota.github.io/docs/Commands/">commands&lt;/a>
and doing a few searches through the github issues looking for issues/questions similar to mine.&lt;/p>
&lt;p>This post is a simple &amp;ldquo;here&amp;rsquo;s how i did it&amp;rdquo; that I wish I had found when I needed to solve the problem.
Hopefully this will save you some trouble!&lt;/p>
&lt;h3 id="mr-coffee">Mr. Coffee&lt;/h3>
&lt;p>A $15 &amp;lsquo;&lt;a href="https://tasmota.github.io/docs/devices/Sonoff-Pow/">smart relay&lt;/a>&amp;rsquo; is all that&amp;rsquo;s needed to turn a simple drip-over coffee maker into a remote-controllable coffee maker.
Immediately, you gain the ability to start brewing coffee in the morning from bed.
With a little extra integration work, start brewing coffee 10 minutes before your alarm is scheduled to go off. Simple quality of life improvement!&lt;/p>
&lt;p>Every coffee maker has at least one safety interlock to disable the heating element if it gets too hot, but some have additional interlocks. Specifically,
my coffee maker has two more interlocks in series with the heating element; if the carafe is removed or the water tank is empty, the circuit is broken and
the heater immediately stops producing heat. From the perspective of the smart relay, the power consumption is either 0 Watts or a bit over 1100 Watts.&lt;/p>
&lt;p>I was not comfortable using Home Assistant to monitor power consumption and then toggle the relay off after observing an interlock kick in.
If something happened to the WiFi connection or the MQTT server or Home Assistant, there&amp;rsquo;s no way to disconnect power from the coffee maker; the relay will stay &amp;lsquo;on&amp;rsquo;.
If the interlock failed, somehow, the heating element would immediately begin pumping out heat when it &lt;em>really&lt;/em> shouldn&amp;rsquo;t be!&lt;/p>
&lt;p>Writing a simple &amp;ldquo;if power consumption drops below 1100 Watts, turn relay off&amp;rdquo; rule would be enough, except there&amp;rsquo;s no way to distinguish between the thermal interlock tripping
and the carafe being removed for a quick pour. The simple rule is incompatible with the extra interlocks; it will prematurely send the brewing 100% of the time the carafe is removed.
If you want to pour a cup of coffee while it&amp;rsquo;s still brewing, this is rather inconvenient.&lt;/p>
&lt;p>Solution: give the user 30 seconds to return the carafe during brewing before turning the relay off.&lt;/p>
&lt;p>From the perspective of the outlet, ignore any lulls in power consumption as long as they&amp;rsquo;re shorter than 30 seconds. Otherwise, assume that an interlock &lt;em>has&lt;/em> tripped.&lt;/p>
&lt;p>This is implemented with two rules:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">Rule1
# When relay1 (heater) is turned on, activate rule2
ON Power1#state=1 DO Rule2 1 ENDON
# and deactivate rule2 when the heater is turned off
ON Power1#state=0 DO Rule2 0 ENDON
# When Timer1 expires, turn the heater off
ON Rules#Timer=1 DO Power1 off ENDON
# When the current used by the heating element rises above 1 Amp, disable Timer1
ON Energy#Current&amp;gt;1 DO RuleTimer1 0 ENDON
# ... and enable rule 2
ON Energy#Current&amp;gt;1 DO Rule2 1 ENDON
Rule2
# Wait for power use to drop to 0; start counting down
ON Energy#Current&amp;lt;.2 DO RuleTimer1 30 ENDON
# and disable rule2 so the timer is not constantly reset
ON Energy#Current&amp;lt;.2 DO Rule2 0 ENDON
&lt;/code>&lt;/pre>&lt;/div>&lt;p>I chose &lt;code>.2&lt;/code> Amps as the trigger, but the logic works the exact same way with Power / Wattage.&lt;/p>
&lt;h2 id="electric-kettle">Electric Kettle&lt;/h2>
&lt;p>I wanted to detect when my electric kettle was done boiling the water so I could play a sound and flash the lights in whichever room I happened to be in at the time.
This is trivial to do with a &amp;lsquo;&lt;a href="https://tasmota.github.io/docs/devices/Sonoff-S31/">smart outlet&lt;/a>&amp;rsquo; and a &lt;a href="https://www.home-assistant.io/integrations/binary_sensor.template/">template sensor&lt;/a> in Home Assistant:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">- &lt;span style="font-weight:bold">platform&lt;/span>: template
&lt;span style="font-weight:bold">sensors&lt;/span>:
&lt;span style="font-weight:bold">kettle_running&lt;/span>:
&lt;span style="font-weight:bold">friendly_name&lt;/span>: &lt;span style="font-style:italic">&amp;#34;Kettle Boiling&amp;#34;&lt;/span>
&lt;span style="font-style:italic"># If the kettle is using more than 5w, assume its on / boiling water&lt;/span>
&lt;span style="font-weight:bold">icon_template&lt;/span>: &amp;gt;-&lt;span style="font-style:italic">
&lt;/span>&lt;span style="font-style:italic"> {% if states(&amp;#39;sensor.kettle_energy_power&amp;#39;) | float &amp;gt; 5 %}
&lt;/span>&lt;span style="font-style:italic"> mdi:kettle-steam
&lt;/span>&lt;span style="font-style:italic"> {% else %}
&lt;/span>&lt;span style="font-style:italic"> mdi:kettle
&lt;/span>&lt;span style="font-style:italic"> {% endif %}&lt;/span>
&lt;span style="font-weight:bold">value_template&lt;/span>: &lt;span style="font-style:italic">&amp;#34;{{states(&amp;#39;sensor.kettle_energy_power&amp;#39;) | float &amp;gt; 5}}&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Only problem, Tasmota only publishes the kettle&amp;rsquo;s power once every 300 seconds. This means &lt;code>sensor.kettle_energy_power&lt;/code> only gets updated every 300s which makes it really hard
to fire off a &lt;em>timely&lt;/em> notification when the kettle is done.
The &amp;lsquo;brute-force&amp;rsquo; solution is to configure Tasmota to transmit the telemetry &lt;a href="https://github.com/arendst/Tasmota/issues/2567">continuously&lt;/a>.
Except there&amp;rsquo;s no need for the Tasmota device on the kettle to be constantly informing Home Assistant that there&amp;rsquo;s no power being used whenever the kettle is not on; my application only cares about the &amp;lsquo;&lt;a href="https://en.wikipedia.org/wiki/Signal_edge">falling edge&lt;/a>&amp;rsquo;.&lt;/p>
&lt;p>Borrow the trigger from the &lt;a href="#mr-coffee">Mr. Coffee&lt;/a> rule and shorten the &lt;a href="https://tasmota.github.io/docs/Commands/#teleperiod">telemetry period&lt;/a> only when the kettle
is consuming more than 1 Watt. Like the coffee maker, it&amp;rsquo;s either consuming 0 Watts or about 1.1 Kilowatt.&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">Rule1
on ENERGY#Power&amp;gt;1 do Backlog TelePeriod 10; Rule2 1 endon
Rule2
on ENERGY#Power=0 do Backlog TelePeriod 1; Rule2 0 endon
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As soon as the kettle starts using more than 1 Watt, configure Tasmota to publish its sensor data every 10 seconds.
I&amp;rsquo;ll get notified that the water is boiling within 10s; much better than 300s!
Once the power consumption goes back down to 0, reset the telemetry update period and disable the rule.&lt;/p>
&lt;p>The second rule must be disabled to prevent constant triggering of the rule when the kettle is not boiling.
Without the &lt;code>Rule2 0&lt;/code>, the console/logs for the device would be full of statements like this repeating every few seconds:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">RUL: ENERGY#POWER&amp;gt;1 performs &amp;#34;TelePeriod 10&amp;#34;
MQT: stat/tasmota_kettle/RESULT = {&amp;#34;TelePeriod&amp;#34;:10}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Hope that helped!&lt;/p></description></item><item><title>PoE at a distance caused terrible cat5 speeds</title><link>https://karlquinsland.com/2020/07/poe-at-a-distance-caused-terrible-cat5-speeds/</link><pubDate>Wed, 01 Jul 2020 00:00:00 +0000</pubDate><guid>https://karlquinsland.com/2020/07/poe-at-a-distance-caused-terrible-cat5-speeds/</guid><description>&lt;p>This is a quick post for made in the hopes that some poor soul in the future will find it and save themselves some time.&lt;/p>
&lt;h2 id="background">Background&lt;/h2>
&lt;p>I&amp;rsquo;ve been experimenting with a few different ways to surface various home automation controls in the appropriate place and at a good time. One prototype host is deployed behind a small LCD under some cabinets in a high traffic area. This host is a raspberry pi 4 with a &lt;a href="https://www.raspberrypi.org/products/poe-hat/">PoE hat&lt;/a>. It boots a very stripped down version of &lt;a href="https://www.raspberrypi.org/downloads/raspberry-pi-os/">Raspberry Pi OS&lt;/a> into a web browser running in Kiosk mode.&lt;/p>
&lt;p>It&amp;rsquo;s pretty simple and does many things well. There&amp;rsquo;s a few small issues that need to be addressed in the CAD files as well as some additional electronic improvements that should be made before I can publish the design / files.&lt;/p>
&lt;p>In any event, this host has been trouble-free until recently. Simple &lt;code>apt update&lt;/code> transfers would take &lt;strong>DAYS&lt;/strong> to complete, simple &lt;code>scp&lt;/code> operations to other hosts on the LAN would trickle by at tens of kB/s. The web app that the host is primarily responsible for displaying would time out or fail to completely load resulting in some &amp;ldquo;a-for-effort&amp;rdquo; &lt;a href="https://www.mavenecommerce.com/2017/10/31/progressive-enhancement-vs-graceful-degradation/">graceful degradation&lt;/a>.&lt;/p>
&lt;h2 id="the-facts">The Facts&lt;/h2>
&lt;p>As soon as I bring up the &lt;code>wlan0&lt;/code> interface and bring down the &lt;code>eth0&lt;/code> interface performance is IMMEDIATELY restored. The web app is responsive and fully loads instantly, &lt;code>scp&lt;/code> is fast like it should be on a LAN and &lt;code>apt update&lt;/code> completes without any errors as fast as my internet connection will let it!&lt;/p>
&lt;p>&lt;strong>Conclusion&lt;/strong>: The problem is &lt;em>not&lt;/em> network related. Both the &lt;code>eth0&lt;/code> and &lt;code>wlan0&lt;/code> interface are on the same &lt;code>vLan&lt;/code> so the bizarre behavior is not likely caused by a QoS policy or firewall rule.&lt;/p>
&lt;p>The rPi and a few other hosts a powered via a a &lt;a href="https://shop.poetexas.com/products/at-4-48v120w/">120 watt&lt;/a> which is in the same closet as my core switch. Two terminations and about 200 feet of cat5 cable later, you get to the rPi host on the other side of the house.&lt;/p>
&lt;p>Continuity tester was used on every segment of the link to confirm the link is good. The segments of the link from the switch to the injector and to the patch-panel all use high quality pre-made cables, as does the final segment from the wall to the rPi. Shocker, they tested fine, just like the in-wall segment.&lt;/p>
&lt;p>Additionally, no other host on the PoE injector is misbehaving. No other host on the PoE injector is indicating that there&amp;rsquo;s not enough power, and the power supply feeding the injector isn&amp;rsquo;t even warm.&lt;/p>
&lt;p>&lt;strong>Conclusion&lt;/strong>: The cables are certainly fine and the PoE injector is &lt;em>probably fine&lt;/em>.&lt;/p>
&lt;p>Next, I disabled the PoE injector all together and use the USBC port on the rPi for power. It was just as performant as with WiFi! I did not expect this result, but it did certainly narrow down the possible problem areas.&lt;/p>
&lt;p>&lt;strong>Conclusion&lt;/strong>: The problem is only present when the host is powered via PoE.&lt;/p>
&lt;p>I was very confident that the PoE injector was not the problem, but in order to be certain, I used a second cheap PoE injector that lives on my bench power supply. Turns out, the same slow speeds manifested with the second injector, too.&lt;/p>
&lt;p>&lt;strong>Conclusion&lt;/strong>: The problem is not in the network, nor is it in the cables, nor is it in the injectors.&lt;/p>
&lt;p>This only leaves one candidate: the host. Unfortunately, there&amp;rsquo;s nothing about the host that screams &amp;ldquo;i&amp;rsquo;m the problem!&amp;rdquo;. The microSD card is new and very fast. There&amp;rsquo;s nothing in the logs indicating a hardware failure. On-device performance (via non-networking benchmarks) is inline with what i&amp;rsquo;d expect.&lt;/p>
&lt;p>Here&amp;rsquo;s two additional facts from some brief testing I did a few weeks ago. I had more or less forgotten about them and only really remembered that:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>When I tried a fresh install of Ubuntu on a fresh microSD card&amp;hellip; same slow speeds.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The host performs &lt;em>perfectly&lt;/em> when plugged into other networks.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>I was &lt;em>confident&lt;/em> then, that the rPi was not the issue and that something about the network was. But I just spent 3 hours systematically testing out every component of the network and concluding that the network is fine!&lt;/p>
&lt;p>&lt;strong>Conclusion&lt;/strong>: I&amp;rsquo;m back where I started; angry and confused.&lt;/p>
&lt;p>The &amp;ldquo;ah ha!&amp;rdquo; moment didn&amp;rsquo;t come until i decided to try my second PoE injector &lt;em>at the client&lt;/em>. Much to my surprise, &lt;strong>it worked!&lt;/strong>.&lt;/p>
&lt;p>After a bit more testing, I determined that the PoE HAT on the rPi is &amp;lsquo;fine&amp;rsquo; when the PoE source is CLOSE&amp;hellip; which probably explains the &amp;lsquo;works fine on other networks&amp;rsquo; fact above.&lt;/p>
&lt;p>That leaves just the &amp;lsquo;problem is OS independent&amp;rsquo; fact which - after thoroughly vetting every part of the network and PoE system - makes it pretty obvious that the problem must be between the rPi and the cat5 cable coming from the wall. There&amp;rsquo;s &lt;em>only&lt;/em> the PoE HAT between the rPi and the cat5 cable coming from the wall. I borrowed a PoE HAT from another host elsewhere on the network and the problematic rPi started behaving again. Network transfer speeds were appropriate and the web app / dashboard was performant again!&lt;/p>
&lt;p>&lt;strong>Conclusion&lt;/strong>: the PoE HAT powering a home automation dashboard has failed in such a way that makes the &lt;code>eth0&lt;/code> interface all but useless. replacing the HAT solved the problem.&lt;/p>
&lt;h2 id="tldr">TL;DR:&lt;/h2>
&lt;p>Several months ago, the home automation dashboard displayed on a PoE powered rPi 4 started to act up. Further investigation showed absolute crap network performance from the host to any other point on the LAN or WAN. After testing each component in isolation, the PoE HAT was the only reaming suspect. After further investigation, the failure mode is &lt;em>not present&lt;/em> when the PoE source is &lt;em>close&lt;/em> to the client, only when the source is far from the client.&lt;/p>
&lt;p>So if you have a PoE powered rPi project out there w/ abysmal &lt;code>eth0&lt;/code> performance, try replacing the PoE hat&amp;hellip;&lt;/p>
&lt;p>Also, if anybody knows &lt;em>why&lt;/em> this happened, I&amp;rsquo;d love to know.&lt;/p></description></item></channel></rss>